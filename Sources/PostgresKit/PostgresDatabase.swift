import DatabaseKit
import Foundation
import NIO
import NIOPostgres
import NIOOpenSSL

public final class PostgresDatabase: Database {
    public struct Config {
        public let address: () throws -> SocketAddress
        public let username: String
        public let password: String
        public let database: String?
        public let tlsConfig: TLSConfiguration?
        
        public init?(url: URL) {
            guard url.scheme == "postgres" else {
                return nil
            }
            guard let username = url.user else {
                return nil
            }
            guard let password = url.password else {
                return nil
            }
            guard let hostname = url.host else {
                return nil
            }
            guard let port = url.port else {
                return nil
            }
            
            let tlsConfig: TLSConfiguration?
            if url.query == "ssl=true" {
                tlsConfig = TLSConfiguration.forClient(certificateVerification: .none)
            } else {
                tlsConfig = nil
            }
            
            self.init(
                hostname: hostname,
                port: port,
                username: username,
                password: password,
                database: url.databaseName,
                tlsConfig: tlsConfig
            )
        }
        
        public init(
            hostname: String,
            port: Int = 5432,
            username: String,
            password: String,
            database: String? = nil,
            tlsConfig: TLSConfiguration? = nil
        ) {
            self.address = {
                return try SocketAddress.makeAddressResolvingHost(hostname, port: port)
            }
            self.username = username
            self.database = database
            self.password = password
            self.tlsConfig = tlsConfig
        }
    }
    
    public var eventLoop: EventLoop
    public let config: Config
    
    public init(config: Config, on eventLoop: EventLoop) {
        self.config = config
        self.eventLoop = eventLoop
    }
    
    public func newConnection() -> EventLoopFuture<PostgresConnection> {
        let address: SocketAddress
        do {
            address = try self.config.address()
        } catch {
            return self.eventLoop.makeFailedFuture(error)
        }
        return PostgresConnection.connect(to: address, on: self.eventLoop).flatMap { conn in
            return conn.authenticate(
                username: self.config.username,
                database: self.config.database,
                password: self.config.password
            ).map { conn }
        }.flatMap { conn in
            if let tlsConfig = self.config.tlsConfig {
                return conn.requestTLS(using: tlsConfig).map { upgraded in
                    if !upgraded {
                        #warning("throw an error here?")
                        print("[Postgres] Server does not support TLS")
                    }
                    return conn
                }
            } else {
                return self.eventLoop.makeSucceededFuture(conn)
            }
        }
    }
}

extension PostgresConnection: DatabaseConnection {
    public var isClosed: Bool {
        #warning("implement is closed")
        return false
    }
}

import SQLKit

extension PostgresRow: SQLRow {
    public func decode<D>(_ type: D.Type, table: String?) throws -> D
        where D: Decodable
    {
        #warning("TODO: implement decoding")
        fatalError()
    }
}

public struct SQLRaw: SQLExpression {
    public var string: String
    public init(_ string: String) {
        self.string = string
    }
    
    public func serialize(to serializer: inout SQLSerializer) {
        serializer.write(self.string)
    }
}

struct PostgresDialect: SQLDialect {
    private var bindOffset: Int
    
    init() {
        self.bindOffset = 0
    }
    
    var identifierQuote: SQLExpression {
        return SQLRaw("\"")
    }
    
    var literalStringQuote: SQLExpression {
        return SQLRaw("'")
    }
    
    mutating func nextBindPlaceholder() -> SQLExpression {
        self.bindOffset += 1
        return SQLRaw("$" + self.bindOffset.description)
    }
    
    func literalBoolean(_ value: Bool) -> SQLExpression {
        switch value {
        case false:
            return SQLRaw("false")
        case true:
            return SQLRaw("true")
        }
    }
    
    var autoIncrementClause: SQLExpression {
        return SQLRaw("GENERATED BY DEFAULT AS IDENTITY")
    }
}

extension PostgresConnection: SQLDatabase {
    public func execute(_ query: SQLExpression, _ onRow: @escaping (SQLRow) throws -> ()) -> EventLoopFuture<Void> {
        var serializer = SQLSerializer(dialect: PostgresDialect())
        query.serialize(to: &serializer)
        print(serializer.sql)
        return self.query(serializer.sql, serializer.binds.map { encodable in
            return PostgresData.null
        }) { row in
            try onRow(row)
        }
    }
}

extension PostgresDatabase: SQLDatabase {
    public func execute(_ query: SQLExpression, _ onRow: @escaping (SQLRow) throws -> ()) -> EventLoopFuture<Void> {
        return self.newConnection().flatMap { conn in
            return conn.execute(query, onRow)
        }
    }
}
